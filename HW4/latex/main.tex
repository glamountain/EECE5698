\documentclass[11pt]{article}

%\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amsfonts}
\usepackage{subfigure}
\usepackage{bm}
\usepackage{listings}
\usepackage{pifont}%
\usepackage{xcolor}
\usepackage{siunitx}

\usepackage{pgfplots,tikz}
\usepackage{fullpage}      % Margens
\usepackage{indentfirst}   % Autoidentar
\usepackage{graphicx}       % Pictures

\newcommand{\answer}[1]{\color{blue}{#1}\color{black}}
\sisetup{scientific-notation = engineering}%

\begin{document}

\noindent\answer{Gerald LaMountain}

\noindent Northeastern University
\hfill April 10, 2018

\noindent Department of Electrical and Computer Engineering
\hfill EECE5698-ST (Spring 2018)

\noindent {} \hfill \textbf{Homework 4}

\noindent \rule{\linewidth}{1.5pt}

\vspace*{.5cm}

\underline{Due date}: Friday 20, April 2018. Hand in at class or send a scanned copy to closas@northeastern.edu

To complete the problems, feel free to consult other sources (i.e., books, internet, etc.) besides class notes.  Justify your answers!

\noindent \rule{\linewidth}{1pt}

\vspace*{1cm}

\answer{Note: Questions are marked in black, while responses are marked in blue.}

\vspace*{1cm}


\textbf{Problem 1}:
Generate the Gold codes used in GPS L1 C/A signal. A template function is provided, \verb|CAcodegen.m|, which implements code generation using the shifting of the second MLS, $G_2[n]$, according to GPS L1 C/A standard. The template contains the complete code to generate the first MLS, $G_1[n]$, but has empty spaces which you need to code. Namely,
\begin{enumerate}
\item[(a)] Generation of $G_2[n]$.

\answer{The matlab function shown below, CAcodegen.m generates the $G_2[n]$, $G_{2,i}[n]$ and $G^{i}[n]$ codes for the $i$-th satellite. The $G_1[n]$ and $G_2[n]$ codes are generated in the for loop which begins on line 32. This for loop records the value of the output register for each code, computes and applies the feedback specified by the code polynomials, and then clocks the registers with the circshift function.}

\item[(b)] Generation of $G_{2,i}[n]$, for the $i$-th satellite.

\answer{ The $G_{2,i}[n]$ code is generated by clocking the set of circular registers in which the $G_2[n]$ is stored by the number of steps appropriate for the given satellite.}

\item[(c)] Generation of $G^{i}[n]$, for the $i$-th satellite.

\answer{ Finally, the output $G^{i}[n]$ is computed by multiplying the $G_1[n]$ and $G_{2,i}[n]$ codes element by element. The use of multiplications instead of modulo-2 addition is possible since we're using a {-1,1} representation rather than a {1,0} representation for the output code.}

\end{enumerate}

\begin{lstlisting}[language=Matlab,numbers=left,stepnumber=1,=\scriptsize,keywordstyle=\color{blue}, commentstyle=\color{green},frame=single]
function [ca_code] = CAcodegen(svnum)
% [ca_used]=CAcodegen(svnum), generates GPS L1 C/A Gold codes
%
% ca_used : a vector containing the desired output sequence
% svnum: Satellite number (can be a vector!), can generate from SV1 to
% SV32

k       = length(svnum);            % number of satellites
ca_code = zeros(k,1023);
G1      = zeros(1,1023);
G2      = zeros(1,1023);

for i=1:k
    
    % the g2s vector holds the appropriate shift of the G2 code to
    % generate the C/A code (ex. for SV#19 -use a G2 shift of
    % g2s(19)=471)
    
    g2s = [5;6;7;8;17;18;139;140;...
        141;251;252;254;255;256;257;258;...
        469;470;471;472;473;474;509;512;...
        513;514;515;516;859;860;861;862];
    g2shift = g2s(svnum(i),1);
    
    g1poly = [3;10];
    g2poly = [2;3;6;8;9;10];
    
    
    %% ***** Generate G1 and G2 codes *****
    g1_reg = -1 * ones(1,10);
    g2_reg = -1 * ones(1,10);
    for n= 1:1023
        
        % Load output register
        G1(n)       = g1_reg(10);
        G2(n)       = g2_reg(10);
        
        % Compute feedback and load shift register
        g1_reg(end) = prod(g1_reg(g1poly));
        g2_reg(end) = prod(g2_reg(g2poly));
        
        % Clock shift register
        g1_reg      = circshift(g1_reg,1,2);
        g2_reg      = circshift(g2_reg,1,2);
        
    end
    
    %% ***** Shift G2 code to get G2i *****
    G2i = circshift(G2,g2shift,2);
    
    
    %% ***** Form single sample C/Acode by multiplying G1 and G2
    ca_code(i,:) = G1 .* G2i;
    
end

\end{lstlisting}


\vspace*{.5cm}

\textbf{Problem 2}:
To validate your implementation of \verb|CAcodegen.m|, you should identify the auto-/cross-correlation properties of Gold codes in your generated sequences. 
Create a script \verb|EECE5698_CAcode.m| 

% and copy the following commands:
% 
% \begin{lstlisting}[language=Matlab,basicstyle=\scriptsize,keywordstyle=\color{blue}, commentstyle=\color{green},frame=single]
% %   EECE5698-ST: GNSS signal processing
% %       GPS L1 C/A code generation
% %
% %   Pau Closas, Spring 2018
% 
% clearvars
% close all
% clc
% 
% % satellite(s) ID
% svnum = 19;
% % C/A chip rate
% Rc = 1.023e6;
% % chip period
% Tc = 1/Rc;
% 
% %% generate code(s)
% [ca_code]=CAcodegen(svnum);
% 
% [ca_code2]=CAcodegen(svnum+1);
% \end{lstlisting}
% 
% \noindent

that will generate two arbitrary codes (in this case $19$ and $20$, but you can change it). Notice that you should use your \verb|CAcodegen.m| function in the \verb|EECE5698_CAcode.m| script. 

\begin{enumerate}
\item[(a)] Plot those codes over time, verify that they take values in $\pm1$.

\answer{As shown in Figure \ref{fig:HW4P2a}, the output of the code generator is within the expected range.}

\begin{figure*}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{HW4/latex/figures/HW4P2a.png}
    \caption{C/A Codes generated with CAcodegen.m}
    \label{fig:HW4P2a}
\end{figure*}

\item[(b)] Implement the auto-correlation function of one of the codes, for instance  \verb|ca_code|, using $1)$ linear correlation and $2)$ circular correlation. Interpret the results.

\answer{Linear correlation is performed using the built-in matlab xcorr function. The following code represents a function xcorr\_circ which performs circular correlation:}

\begin{lstlisting}[language=Matlab,numbers=left,stepnumber=1,=\scriptsize,keywordstyle=\color{blue}, commentstyle=\color{green},frame=single]
function [cxcor, lags] = xcorr_circ(a,b)

% Normalize
a = a(:) / norm(a);
b = b(:) / norm(b);

cxcor = zeros(1,length(b));
% Shift and compute cross correlation at each shift
for k=1:length(b)
    
    cxcor(k) = a' * b;
    b = circshift(b,1,1);

end
lags = [0:length(b)-1];
\end{lstlisting}


\answer{As shown in Figure \ref{fig:HW4P2b}, the result of linear autocorrelation is a single peak located at }

\begin{figure*}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{HW4/latex/figures/HW4P2b.png}
    \caption{C/A Codes generated with CAcodegen.m}
    \label{fig:HW4P2b}
\end{figure*}

\item[(c)] Compute the auto-correlation of the concatenation of three PRN codes \verb|[ca_code ca_code ca_code]| with the local replica of one code \verb|ca_code|. Comment the results. 
\item[(d)] Verify the auto-correlation properties for one of the codes you generated, for instance \verb|ca_code|. Use linear and circular correlation, as in (b). Explain the results.
\item[(e)] Verify the cross-correlation properties between \verb|ca_code| and \verb|ca_code2|, the codes you generated. Use linear and circular correlation, as in (b). Explain your results.
\end{enumerate}

Hint: in implementing linear and circular correlation, make use of built-in Matlab functions \verb|xcorr|, \verb|fft|, and \verb|ifft|

\begin{lstlisting}[language=Matlab,numbers=left,stepnumber=1,=\scriptsize,keywordstyle=\color{blue}, commentstyle=\color{green},frame=single]
\end{lstlisting}
\vspace*{.5cm}

\textbf{Problem 3}:
Load \verb|HW4P3.mat| by typing \verb|load HW4P3| in Matlab shell. That file contains a variable \verb|ca_code_hidden|, a Gold code sequence from the GPS L1 C/A constellation. Determine which satellite's code corresponds to by looping over all possible values (i.e., $32$, which is the maximum number of GPS satellites). Explain your answer.


\vspace*{.5cm}

\textbf{Problem 4}:
Detect satellites from a real data recording. We will use a similar procedure as in Problem 3 (i.e., looping over possible satellites and correlating with the corresponding spreading code). 

Below there is a code implementing non-coherent acquisitions over \verb|Nnci| CAFs. Copy-paste this code into a script and place the file \verb|realGPSL1capture.bin| in the same folder, that file contains a real data recording of L1 band signal ($f_s=10$ MHz). You need also \verb|computeCAF.m| and \verb|ResampleCode.m| in the folder.

% \begin{lstlisting}[language=Matlab,basicstyle=\scriptsize,keywordstyle=\color{blue}, commentstyle=\color{green},frame=single]
% % signal parameters
% fs = 10e6;          % Sampling frequency
% fIF = 0;            % Intermediate frequency
% fc = 1.023e6;       % Code rate of the code [Hz]
% Tcoh = 0.001;       % Coherent integration time [s]
% Nc = Tcoh * fs;     % number of samples contained in the coherent integration time
% 
% % Acquisition parameters
% Nd = 81;            % Number of Doppler bins
% DopStep = 125;      % Doppler bin size in Hz
% secondOfData = 0.1; % Seconds of data to read
% Nnci = 1;           % number of non-coherent integrations of the CAF
% SVIDs = 1:32;          % satellite vehicles (SV) to detect [7 16 19 21 22 25]
% 
% % read file with the IF capture
% fid = fopen ('realGPSL1capture.bin','r');
% [data, cnt_data] = fread(fid, 2 * secondOfData * fs, 'int8');
% data = data(1:2:end) + 1i * data(2:2:end);
% 
% CAF_aux = zeros(Nd,Nc);
% DopplerEst = -ones(1,32);
% DelayEst = -ones(1,32);
% 
% % generate local replica and resample from Tc to Ts>Tc
% 
% % loop over all possible satellites
% for svnum = SVIDs
% 
%     [ca_code]=CAcodegen(svnum);
%     % Resample the code at data sampling frequency
%     ca_code_resampled = ResampleCode( ca_code, Nc, fs, 0, fc );   
%     
%     CAF = 0;        % initialized CAF to zero every time
%     
%     % loop to average over noncoherent integrations
%     for ii = 1:Nnci
%         y =  data( (ii - 1) * Nc + (1:Nc) ).';   % use just 1 period of code at the time
%         
%         % loop over frequency bins
%         for ff=1:Nd
%             fdbin = fIF/fs + (ff - ceil(Nd/2))*DopStep/fs;   % normalized Doppler bin
%             CAF_aux(ff,:) = computeCAF(y, ca_code_resampled, fdbin);
%         end
%         % integrate non-coherently the ii test statistics |CAF|^2 
%         CAF = CAF + abs(CAF_aux).^2;
% 
%         % plot 2D grid search
%         CAF_normalized = CAF/max(max(CAF));     % normalize to 1 the maximum value
%         
%         figure(svnum)
%         surf((0:(Nc - 1)) / fs, ((1:Nd) - ceil(Nd/2))*DopStep, CAF_normalized, 'EdgeColor', 'none');
%         axis tight, set( gca, 'FontSize', 16 )
%         xlabel('Code delay [s]'), ylabel('Doppler [Hz]')
%         title(['SV ' num2str(svnum) ' , ' num2str(ii) ' non-coherent integrations'])
% %         pause
%     end
%     pause
%     
%     % estimate Doppler (if satellite detected)
%     [~, DopInd] = max(max(CAF.'));
%     DopplerEst(svnum) = fIF + (DopInd - ceil(Nd/2))*DopStep;
% 
%     % estimate time-delay (if satellite detected)
%     [~, codInd] = max(max(CAF));
%     DelayEst(svnum) =  (codInd - 1) / fs;
% 
% end
% \end{lstlisting}

Notice that you would need to generate the codes with \verb|CAcodegen.m|. If you were not able to work that function out, you might load \verb|CAcodes.mat|, which contains a matrix with the Gold code of each satellite (total $32$) in the corresponding row (that is, use \verb|[ca_code]=ca_code_matrix(svnum,:);| instead).


\begin{enumerate}
\item[(a)] Go through the code and explain (preferably supporting your discussion with math) the different steps implemented. 
\item[(b)] Run the code with \verb|Nnci=1|. Explain the processing that takes place in the receiver in this configuration. How many satellites are you able to clearly detect (i.e., distinguish from noise floor)? 
\item[(c)] Gradually increase \verb|Nnci| from $1$ to $10$ non-coherent integrations. Explain the processing that takes place in the receiver in this configuration. How many satellites are you able to clearly detect (i.e., distinguish from noise floor)? Explain the results. 
\item[(d)] At the light of the results, which satellites are more likely to be present in the capture? Once a satellite is acquired, which information is passed on to the tracking loops?
\end{enumerate}


\end{document}




